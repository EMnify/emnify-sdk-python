:py:mod:`emnify.constants`
==========================

.. py:module:: emnify.constants


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   emnify.constants.ExtendedEnum
   emnify.constants.DeviceSort
   emnify.constants.IdValues
   emnify.constants.RequestsType
   emnify.constants.AuthenticateRequestsUrl
   emnify.constants.RequestDefaultHeadersKeys
   emnify.constants.RequestDefaultHeadersValues
   emnify.constants.DeviceStatuses
   emnify.constants.SimStatusesID
   emnify.constants.SimStatusesDict
   emnify.constants.ResponseHeaders
   emnify.constants.SimSort
   emnify.constants.RequestUrls




.. py:class:: ExtendedEnum(*args, **kwds)

   Bases: :py:obj:`enum.Enum`

   Create a collection of name/value pairs.

   Example enumeration:

   >>> class Color(Enum):
   ...     RED = 1
   ...     BLUE = 2
   ...     GREEN = 3

   Access them by:

   - attribute access::

   >>> Color.RED
   <Color.RED: 1>

   - value lookup:

   >>> Color(1)
   <Color.RED: 1>

   - name lookup:

   >>> Color['RED']
   <Color.RED: 1>

   Enumerations can be iterated over, and know how many members they have:

   >>> len(Color)
   3

   >>> list(Color)
   [<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]

   Methods can be added to enumerations, and members can have their own
   attributes -- see the documentation for details.

   .. py:method:: list()
      :classmethod:



.. py:class:: DeviceSort(*args, **kwds)

   Bases: :py:obj:`ExtendedEnum`

   Create a collection of name/value pairs.

   Example enumeration:

   >>> class Color(Enum):
   ...     RED = 1
   ...     BLUE = 2
   ...     GREEN = 3

   Access them by:

   - attribute access::

   >>> Color.RED
   <Color.RED: 1>

   - value lookup:

   >>> Color(1)
   <Color.RED: 1>

   - name lookup:

   >>> Color['RED']
   <Color.RED: 1>

   Enumerations can be iterated over, and know how many members they have:

   >>> len(Color)
   3

   >>> list(Color)
   [<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]

   Methods can be added to enumerations, and members can have their own
   attributes -- see the documentation for details.

   .. py:attribute:: ID
      :annotation: = id

      

   .. py:attribute:: STATUS
      :annotation: = status

      

   .. py:attribute:: LAST_UPDATED
      :annotation: = last_updated

      

   .. py:attribute:: CREATED
      :annotation: = created

      

   .. py:attribute:: NAME
      :annotation: = name

      

   .. py:attribute:: TAGS
      :annotation: = tags

      

   .. py:attribute:: IP_ADDRESS
      :annotation: = ip_address

      

   .. py:attribute:: IMEI
      :annotation: = imei

      


.. py:class:: IdValues(*args, **kwds)

   Bases: :py:obj:`ExtendedEnum`

   Create a collection of name/value pairs.

   Example enumeration:

   >>> class Color(Enum):
   ...     RED = 1
   ...     BLUE = 2
   ...     GREEN = 3

   Access them by:

   - attribute access::

   >>> Color.RED
   <Color.RED: 1>

   - value lookup:

   >>> Color(1)
   <Color.RED: 1>

   - name lookup:

   >>> Color['RED']
   <Color.RED: 1>

   Enumerations can be iterated over, and know how many members they have:

   >>> len(Color)
   3

   >>> list(Color)
   [<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]

   Methods can be added to enumerations, and members can have their own
   attributes -- see the documentation for details.

   .. py:attribute:: ID
      :annotation: = id

      


.. py:class:: RequestsType(*args, **kwds)

   Bases: :py:obj:`ExtendedEnum`

   Create a collection of name/value pairs.

   Example enumeration:

   >>> class Color(Enum):
   ...     RED = 1
   ...     BLUE = 2
   ...     GREEN = 3

   Access them by:

   - attribute access::

   >>> Color.RED
   <Color.RED: 1>

   - value lookup:

   >>> Color(1)
   <Color.RED: 1>

   - name lookup:

   >>> Color['RED']
   <Color.RED: 1>

   Enumerations can be iterated over, and know how many members they have:

   >>> len(Color)
   3

   >>> list(Color)
   [<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]

   Methods can be added to enumerations, and members can have their own
   attributes -- see the documentation for details.

   .. py:attribute:: GET
      :annotation: = get

      

   .. py:attribute:: POST
      :annotation: = post

      

   .. py:attribute:: PUT
      :annotation: = put

      

   .. py:attribute:: DELETE
      :annotation: = delete

      

   .. py:attribute:: PATCH
      :annotation: = patch

      


.. py:class:: AuthenticateRequestsUrl(*args, **kwds)

   Bases: :py:obj:`ExtendedEnum`

   Create a collection of name/value pairs.

   Example enumeration:

   >>> class Color(Enum):
   ...     RED = 1
   ...     BLUE = 2
   ...     GREEN = 3

   Access them by:

   - attribute access::

   >>> Color.RED
   <Color.RED: 1>

   - value lookup:

   >>> Color(1)
   <Color.RED: 1>

   - name lookup:

   >>> Color['RED']
   <Color.RED: 1>

   Enumerations can be iterated over, and know how many members they have:

   >>> len(Color)
   3

   >>> list(Color)
   [<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]

   Methods can be added to enumerations, and members can have their own
   attributes -- see the documentation for details.

   .. py:attribute:: V1_AUTHENTICATE
      :annotation: = /v1/authenticate

      


.. py:class:: RequestDefaultHeadersKeys(*args, **kwds)

   Bases: :py:obj:`ExtendedEnum`

   Create a collection of name/value pairs.

   Example enumeration:

   >>> class Color(Enum):
   ...     RED = 1
   ...     BLUE = 2
   ...     GREEN = 3

   Access them by:

   - attribute access::

   >>> Color.RED
   <Color.RED: 1>

   - value lookup:

   >>> Color(1)
   <Color.RED: 1>

   - name lookup:

   >>> Color['RED']
   <Color.RED: 1>

   Enumerations can be iterated over, and know how many members they have:

   >>> len(Color)
   3

   >>> list(Color)
   [<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]

   Methods can be added to enumerations, and members can have their own
   attributes -- see the documentation for details.

   .. py:attribute:: ACCEPT
      :annotation: = accept

      

   .. py:attribute:: AUTHORIZATION
      :annotation: = authorization

      

   .. py:attribute:: XEmnOriginApp
      :annotation: = x-emn-origin-app

      

   .. py:attribute:: XEmnOriginAppVersion
      :annotation: = x-emn-origin-app-version

      


.. py:class:: RequestDefaultHeadersValues(*args, **kwds)

   Bases: :py:obj:`ExtendedEnum`

   Create a collection of name/value pairs.

   Example enumeration:

   >>> class Color(Enum):
   ...     RED = 1
   ...     BLUE = 2
   ...     GREEN = 3

   Access them by:

   - attribute access::

   >>> Color.RED
   <Color.RED: 1>

   - value lookup:

   >>> Color(1)
   <Color.RED: 1>

   - name lookup:

   >>> Color['RED']
   <Color.RED: 1>

   Enumerations can be iterated over, and know how many members they have:

   >>> len(Color)
   3

   >>> list(Color)
   [<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]

   Methods can be added to enumerations, and members can have their own
   attributes -- see the documentation for details.

   .. py:attribute:: APPLICATION_JSON
      :annotation: = application/json

      

   .. py:attribute:: BEARER_TOKEN
      :annotation: = Bearer {}

      

   .. py:attribute:: PYTHONSDK_VERSION
      

      

   .. py:attribute:: PYTHONSDK
      :annotation: = PythonSDK

      


.. py:class:: DeviceStatuses(*args, **kwds)

   Bases: :py:obj:`ExtendedEnum`

   Create a collection of name/value pairs.

   Example enumeration:

   >>> class Color(Enum):
   ...     RED = 1
   ...     BLUE = 2
   ...     GREEN = 3

   Access them by:

   - attribute access::

   >>> Color.RED
   <Color.RED: 1>

   - value lookup:

   >>> Color(1)
   <Color.RED: 1>

   - name lookup:

   >>> Color['RED']
   <Color.RED: 1>

   Enumerations can be iterated over, and know how many members they have:

   >>> len(Color)
   3

   >>> list(Color)
   [<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]

   Methods can be added to enumerations, and members can have their own
   attributes -- see the documentation for details.

   .. py:attribute:: ENABLED_ID
      :annotation: = 0

      

   .. py:attribute:: DISABLED_ID
      :annotation: = 1

      

   .. py:attribute:: DELETED_ID
      :annotation: = 2

      

   .. py:attribute:: ENABLED_DICT
      

      

   .. py:attribute:: DISABLED_DICT
      

      

   .. py:attribute:: DELETED_DICT
      

      


.. py:class:: SimStatusesID(*args, **kwds)

   Bases: :py:obj:`ExtendedEnum`

   Create a collection of name/value pairs.

   Example enumeration:

   >>> class Color(Enum):
   ...     RED = 1
   ...     BLUE = 2
   ...     GREEN = 3

   Access them by:

   - attribute access::

   >>> Color.RED
   <Color.RED: 1>

   - value lookup:

   >>> Color(1)
   <Color.RED: 1>

   - name lookup:

   >>> Color['RED']
   <Color.RED: 1>

   Enumerations can be iterated over, and know how many members they have:

   >>> len(Color)
   3

   >>> list(Color)
   [<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]

   Methods can be added to enumerations, and members can have their own
   attributes -- see the documentation for details.

   .. py:attribute:: ISSUED_ID
      :annotation: = 0

      

   .. py:attribute:: ACTIVATED_ID
      :annotation: = 1

      

   .. py:attribute:: SUSPENDED_ID
      :annotation: = 2

      

   .. py:attribute:: DELETED_ID
      :annotation: = 3

      

   .. py:attribute:: FACTORY_TEST_ID
      :annotation: = 4

      


.. py:class:: SimStatusesDict(*args, **kwds)

   Bases: :py:obj:`ExtendedEnum`

   Create a collection of name/value pairs.

   Example enumeration:

   >>> class Color(Enum):
   ...     RED = 1
   ...     BLUE = 2
   ...     GREEN = 3

   Access them by:

   - attribute access::

   >>> Color.RED
   <Color.RED: 1>

   - value lookup:

   >>> Color(1)
   <Color.RED: 1>

   - name lookup:

   >>> Color['RED']
   <Color.RED: 1>

   Enumerations can be iterated over, and know how many members they have:

   >>> len(Color)
   3

   >>> list(Color)
   [<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]

   Methods can be added to enumerations, and members can have their own
   attributes -- see the documentation for details.

   .. py:attribute:: ISSUED_DICT
      

      

   .. py:attribute:: ACTIVATED_DICT
      

      

   .. py:attribute:: SUSPENDED_DICT
      

      

   .. py:attribute:: DELETED_DICT
      

      

   .. py:attribute:: FACTORY_TEST_DICT
      

      


.. py:class:: ResponseHeaders(*args, **kwds)

   Bases: :py:obj:`ExtendedEnum`

   Create a collection of name/value pairs.

   Example enumeration:

   >>> class Color(Enum):
   ...     RED = 1
   ...     BLUE = 2
   ...     GREEN = 3

   Access them by:

   - attribute access::

   >>> Color.RED
   <Color.RED: 1>

   - value lookup:

   >>> Color(1)
   <Color.RED: 1>

   - name lookup:

   >>> Color['RED']
   <Color.RED: 1>

   Enumerations can be iterated over, and know how many members they have:

   >>> len(Color)
   3

   >>> list(Color)
   [<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]

   Methods can be added to enumerations, and members can have their own
   attributes -- see the documentation for details.

   .. py:attribute:: COUNT_PER_PAGE
      :annotation: = X-Count-Per-Page

      

   .. py:attribute:: CURRENT_PAGE
      :annotation: = X-Current-Page

      

   .. py:attribute:: TOTAL_PAGES
      :annotation: = X-Total-Pages

      

   .. py:attribute:: TOTAL_COUNT
      :annotation: = X-Total-Count

      


.. py:class:: SimSort(*args, **kwds)

   Bases: :py:obj:`ExtendedEnum`

   Create a collection of name/value pairs.

   Example enumeration:

   >>> class Color(Enum):
   ...     RED = 1
   ...     BLUE = 2
   ...     GREEN = 3

   Access them by:

   - attribute access::

   >>> Color.RED
   <Color.RED: 1>

   - value lookup:

   >>> Color(1)
   <Color.RED: 1>

   - name lookup:

   >>> Color['RED']
   <Color.RED: 1>

   Enumerations can be iterated over, and know how many members they have:

   >>> len(Color)
   3

   >>> list(Color)
   [<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]

   Methods can be added to enumerations, and members can have their own
   attributes -- see the documentation for details.

   .. py:attribute:: id
      :annotation: = ID

      

   .. py:attribute:: issuer_org
      :annotation: = ISSUER_ORG

      

   .. py:attribute:: reseller_org
      :annotation: = RESELLER_ORG

      

   .. py:attribute:: customer_org
      :annotation: = CUSTOMER_PRG

      

   .. py:attribute:: iccid
      :annotation: = ICCID

      

   .. py:attribute:: status
      :annotation: = STATUS

      

   .. py:attribute:: production_date
      :annotation: = PRODUCTION_DATE

      

   .. py:attribute:: endpoint
      :annotation: = ENDPOINT

      

   .. py:attribute:: model
      :annotation: = MODEL

      


.. py:class:: RequestUrls(*args, **kwds)

   Bases: :py:obj:`ExtendedEnum`

   Create a collection of name/value pairs.

   Example enumeration:

   >>> class Color(Enum):
   ...     RED = 1
   ...     BLUE = 2
   ...     GREEN = 3

   Access them by:

   - attribute access::

   >>> Color.RED
   <Color.RED: 1>

   - value lookup:

   >>> Color(1)
   <Color.RED: 1>

   - name lookup:

   >>> Color['RED']
   <Color.RED: 1>

   Enumerations can be iterated over, and know how many members they have:

   >>> len(Color)
   3

   >>> list(Color)
   [<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]

   Methods can be added to enumerations, and members can have their own
   attributes -- see the documentation for details.

   .. py:attribute:: ENDPOINT_IN_URL
      :annotation: = /v1/endpoint/{endpoint_id}

      


